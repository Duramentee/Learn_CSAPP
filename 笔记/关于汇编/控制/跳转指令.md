# 跳转指令

## 1. 14种跳转指令

![](.\跳转指令.png)

### 1.1 无条件跳转

#### 1.1.1 jmp（无条件跳转）

有直接跳转(直接跟一个标号比如 `.L1` )和间接跳转(跟一个寄存器或者内存位置读出的地址)两种形式

- **条件**：无条件。
- **设置**：总是跳转到指定的地址或标签。
- **用途**：用于无条件地转移程序控制流，常用于创建循环或跳过代码。

### 1.2有条件跳转

#### 1.2.1 有符号跳转

##### 	1.2.1.1 je / jz（跳转如果相等/跳转如果为零）

- **条件**：如果零标志 `ZF` 被设置（表示上一步比较结果相等或结果为零）。
- **设置**：如果 `ZF = 1`，则跳转到指定标签；否则不跳转。
- **用途**：用于条件分支，检测是否相等或是否为零。

##### 	1.2.1.2 jne / jnz（跳转如果不相等/跳转如果不为零）

- **条件**：如果零标志 `ZF` 未被设置（表示上一步比较结果不相等或结果不为零）。
- **设置**：如果 `ZF = 0`，则跳转到指定标签；否则不跳转。
- **用途**：用于条件分支，检测不相等或非零条件。

##### 	1.2.1.3 jg / jnle（跳转如果大于）

- **条件**：如果零标志 `ZF` 为 0 且符号标志 `SF` 为 0（表示上一步比较结果为正）。
- **设置**：如果 `ZF = 0` 且 `SF = 0`，则跳转到指定标签；否则不跳转。
- **用途**：用于判断有符号数的大小关系。

##### 	1.2.1.4 jl / jnge（跳转如果小于）

- **条件**：如果符号标志 `SF` 为 1（表示上一步比较结果为负）。
- **设置**：如果 `SF = 1`，则跳转到指定标签；否则不跳转。
- **用途**：用于判断有符号数的大小关系。

##### 	1.2.1.5 jge（跳转如果大于或等于）

- **条件**：如果符号标志 `SF` 为 0（表示上一步比较结果为正或零）。
- **设置**：如果 `SF = 0`，则跳转到指定标签；否则不跳转。
- **用途**：用于判断有符号数的大小关系。

##### 	1.2.1.6 jle（跳转如果小于或等于）

- **条件**：如果零标志 `ZF` 为 1 或符号标志 `SF` 为 1（表示上一步比较结果为负或零）。
- **设置**：如果 `ZF = 1` 或 `SF = 1`，则跳转到指定标签；否则不跳转。
- **用途**：用于判断有符号数的大小关系。



#### 1.2.2无符号跳转

##### 1.2.2.1 ja / jnbe（跳转如果无符号大于）

- **条件**：如果零标志 `ZF` 为 0 且进位标志 `CF` 为 0（表示无符号比较结果为大于）。
- **设置**：如果 `ZF = 0` 且 `CF = 0`，则跳转到指定标签；否则不跳转。
- **用途**：用于判断无符号数的大小关系。

##### 1.2.2.2 jb / jnae（跳转如果无符号小于）

- **条件**：如果进位标志 `CF` 为 1（表示无符号比较结果为小于）。
- **设置**：如果 `CF = 1`，则跳转到指定标签；否则不跳转。
- **用途**：用于判断无符号数的大小关系。

##### 1.2.2.3 jae / jnb（跳转如果无符号大于或等于）

- **条件**：如果进位标志 `CF` 为 0（表示无符号比较结果为大于或等于）。
- **设置**：如果 `CF = 0`，则跳转到指定标签；否则不跳转。
- **用途**：用于判断无符号数的大小关系。

##### 1.2.2.4 jbe / jna（跳转如果无符号小于或等于）

- **条件**：如果零标志 `ZF` 为 1 或进位标志 `CF` 为 1（表示无符号比较结果为小于或等于）。
- **设置**：如果 `ZF = 1` 或 `CF = 1`，则跳转到指定标签；否则不跳转。
- **用途**：用于判断无符号数的大小关系。



## 2.跳转指令的编码



### 2.1 连接前的反汇编代码

此处有点绕,注意看书上的例子

![](.\跳转指令的编码的一个例子png.png)

直接看反汇编后的这个版本,这是一个还没有链接的版本能注意到这里出现了两条jump指令,第2行的jmp和第5行的jg.

首先看第二行,第一个jump指令,此处有一个jmp指令,其后操作数为`8`,也就是跳转到地址为`8`处,那么意味着接下来要跳转到第四行.

其次再看第5行,第二个jump指令,此处有一个jg指令,其后操作数为`5`,也就是跳转到地址为`5`处,那么意味着接下来要跳转到第3行.

此处还要理解一个**很重要的点**:对于二进制代码(也就是第三大列这一些二进制),如果我们采用的是 **与PC(程序计数器)相对的跳转目标编码**,那么我们在执行PC相对寻址的时候,**程序计数器的值实际上是跳转指令后面的那条指令的地址**,而不是跳转指令本身的地址.产生这种规则的原因主要是历史问题,当时的处理器会将更新程序计数器作为执行一条指令的第一步.

回到这个例子理解这一点,对于第二行这一个jump指令, `eb 03` 要注意计算的并不是本行地址所在的3 + 相对偏移3, 而是这一行之后的下一条语句地址所在的5(至于为什么是5, 因为采用相对跳转时jmp占了两个字节,所以是3+2=5) + 3, 所以会跳转到8.

同理,第二个jump指令, `7f f8`, 将会按照 d + f8 计算, 而 0xf8 在补码表示下对应十进制为 -8, 那么最终计算为 13 - 8 = 5, 最后也就跳转到了地址 5 ,也就是第三行.



### 2.3 链接后的反汇编代码

在链接之后可能会如下图所示

![](.\跳转指令的编码_反汇编后.png)

此处的地址被填入了运行时的实际地址,jump跳转规则和上边连接前是一致的,不多看了.







