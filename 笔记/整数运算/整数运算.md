# 整数运算

## 1.无符号加法

一些情况下会导致加法运算后溢出

对于两个非负整数 x 和 y, 满足0 <= x, y < 2 ^ w (w即该数对应二进制表达下的位数),计算两者的和时就会有一个可能的范围 0 <= (x + y) <= 2 ^ (w + 1) - 2.

![](.\整数运算5.png)

表示这个和可能需要 w + 1 位,比如: 1001+1100=10101 (9+12=21).当发生此种情况时,c编译器将会丢弃运算后的进位即10101将保留最低四位得到0101 (5).

此种情况和取模运算一致,也就是21 mod 16 = 5.

那么我们可以认为,对于无符号数加法发生溢出的情况为

![](.\整数运算1.png)

(1)当 x+y < 2^w 也就是当进位后超过二进制对应的最大位时,此时正常没有溢出.

(2)当 2^w <= x+y <= 2^(w+1) 也就是当和没有超过二进制对应的最大位时,此时发生了溢出,结果将为 x+y-2^w.也可以理解为取模

### 无符号数求反

![](.\整数运算2.png)

求逆元,对于一个无符号数x,x = 0 时,其逆元为0, x > 0 时, 其逆元为2^w - x.

![](.\整数运算3.png)

对于证明理解, x + x的逆元一定为0, 那么一定存在 x + x的逆元 对 2^w 求模结果为0 (考虑一个情况 100 + -100 = 0, 如果为 100 + -99 = 1, 此时对100取模结果为1,当和为0时才会有对100的模为0) (x + 2^w - x) mod 2^w = 0, 故 2^w - x 一定为x的逆元.

练习题答案如下:

![](.\整数运算4.png)

### 无符号数溢出检测

```c
#include <stdbool.h>

bool uadd_ok(unsigned x, unsigned y) {
	if (x + y < x) {
		return false;
	} else {
		return true;
	}
}
```



## 2.补码(有符号)加法

![](.\整数运算6.png)

![](.\整数运算7.png)

x 和 y 的下限为有符号数对应最小值 -2^(w-1) ,上限为有符号数对应最大值 2^(w-1) - 1 ,那么两者的和就是介于 -(2^w) 到 (2^w)-2 之间的数.

根据图示一共有四种情况

### 情况3和2

两种情况可认为是同一种,也就是**没有发生溢出**的情况,此时正常存储结果.

### 情况4

此时发生了**正溢出**(也就是两个正数相加产生进位时超过了最大位)(当且仅当两个有符号数均为正数才有可能发生),这时候产生错误结果为 x+y-2^w ,与无符号数发生溢出的情况相同.

### 情况1

此事发生了**负溢出**(也就是两个负数相加(也可想成是一个负数减去另一个负数)(当且仅当两个有符号数均为负数才有可能发生),这时候产生错误结果为 x+y+2^w )

### 一些例子:

![](.\整数运算8.png)

### 补码加法(有符号数)溢出检测

![](.\整数运算9.png)

分为两种情况

(1) x>0 && y>0 但是和s<=0 此时发生了正溢出.

(2) x<0 && y<0 但是和s>=0 此时发生了负溢出.

```c
#include <stdbool.h>

bool is_positive_overflow(int x, int y) {
	const int sum = x + y;
	return (x > 0 && y > 0 && sum <= 0);
}

bool is_negative_overflow(int x, int y) {
	const int sum = x + y;
	return (x < 0 && y < 0 && sum >= 0);
}

bool tadd_ok(int x, int y) {
	return !(is_positive_overflow(x, y) || is_negative_overflow(x, y));
}
```

## 3.无符号乘法

![](.\整数运算10.png)

对于0<=x,y<=(2^w)-1, 其乘积的取值范围在![](.\整数运算11.png)

由此可见表达乘积可能需要2w位,但是在c中无符号乘法被定义位产生w位的值,也就是截断为w位.

例如对于4位乘法:4(0100) * 5(0101) = 20(10100),由于只能容纳四位,所以结果将会被截断得到:0100(4),也就是 20 mod 16 = 4.

## 4.补码(有符号)乘法

![](.\整数运算12.png)

也就是分为了两步完成,第一步与无符号乘法相同(也就是将该有符号数认为是无符号数计算),计算乘积然后截断为w位,第二步再将该截断后的结果(无符号数)转换为补码.

无符号乘法和补码乘法的位级等价性

![](.\整数运算13.png)

这段意思其实就是,不论使用无符号表示还是补码表示,尽管乘积真正结果可能不同,但是在发生溢出时,截断后的结果是相同的,几个例子可以见下表:

![](.\整数运算14.png)

## 5.乘法溢出检测

```c
// 方法一直接采用溢出形式下检测
#include <stdbool.h>

bool tmult_ok(int x, int y) {
    int p = x * y;
    // !x 涵盖了 x = 0 以及 y = 0
    // p / x == y 用以判断其他情况, 如果不等就是溢出.
    return !x || p / x == y;
}
```

```c
// 方法二采用扩大位数的真实情况检测(本例子针对int32做检测扩大为int64)
#include <stdbool.h>
#include <stdint.h>

bool tmult_ok(int x, int y) {
    int64_t p = (int64_t)x * (int64_t)y;
    // 两种进制表达下不相等那就是溢出了
    return p == (int)p;
}
```

## 6.一个实际上的应用(修改一个数值相关的bug)

![](.\整数运算15.png)

![](.\整数运算16.png)

注意: malloc 的参数为 size_t ,在此处就是 uint32_t.

A:这段代码并没有改进,asize虽然计算出了不会被截断的结果,但是作为参数传入malloc时仍然会被转换为 uint32_t 丢失了本应想要的位数.

```c
// B的解答
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

void* copy_elements(void *ele_src[], int ele_cnt, size_t ele_size) {
	// 想要分配的大小
	const int64_t required_size = ele_cnt * (int64_t)ele_size;
	// 实际传入 malloc 作为参数的大小
	const size_t request_size = ele_cnt * ele_size;
	// 如果不相等那就是发生了溢出,直接返回 NULL
	if (required_size != request_size) {
		return NULL;
	}

	// 每一处就继续进行,如果分配 result 得到了 NULL 也就是分配出错,直接返回 NULL
	void *result = malloc(request_size);
	if (result == NULL) {
		return NULL;
	}

	// 循环做数据的拷贝
	void *next = result;
	for (int i = 0; i < ele_cnt; ++i) {
		memcpy(next, ele_src[i], ele_size);
		next += ele_size;
	}

	// 返回得到的新容器首地址
	return result;
}
```

## 7.乘以常数

![](.\整数运算17.png)

也就是乘了2的多少次幂就将x左移多少位.

当发生溢出时,与乘法溢出情形一致,c处理器将会按照截断方式进行处理.

例如四位运算:11(1011) * 2^2(0100) = 44(101100),将被截断为1100,也就是44 mod 16 = 12.

c编译器试图对乘法做出优化,将乘法优化为位移和加减法的组合,例如 x*14 将被优化为(x<<3) + (x<<2) + (x<<1), 或者更好的情况为: (x<<4) - (x<<1).

## 8.除以2的幂

除法相较乘法更加的慢,位移加减法等运算一般是1时钟周期,乘法比较其慢了几倍到几十倍,而除法则要30倍或以上,因此整数除法也同样采用了位移(此时用右移)和加减法来做替代.

![](.\整数运算19.png)

要注意:在使用移位操作替代除法时将会改变除法的舍入原则,直接使用除法总是倾向于向0舍入,也就是对于商为正数将向下舍入,对于商为负数,将向上舍入.

但是在使用移位作为替代时,即便商为负数也会向下舍入.

### 对于无符号数的除法

![](.\整数运算18.png)

直接做逻辑右移即可,不用多考虑.

对于移位舍入的情况,使用添加偏置的方式解决.

![](.\整数运算20.png)