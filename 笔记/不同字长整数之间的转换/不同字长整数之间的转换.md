# 不同字长整数之间的转换



## 小转大

### 较小字长的无符号数转为较大字长的无符号数

例如 unsigned char 转为 unsigned short (8位转16位)

![](.\不同字长整数之间的转换1.png)

很直观,直接将低位复制到更大的数对应低位即可,其余的高位全部用0补全



### 较小字长的有符号数转为较大字长的有符号数

例如 char 转 short (8 转 16)

![](.\不同字长整数之间的转换2.png)

#### 情况一:最高位为0

与无符号数情况一致,直接补0即可

#### 情况二:最高位为1

直接将低位复制到更大的数对应低位即可,其余的高位全部用1补全(书上有数学证明)



## 大转小

### 较大字长的无符号数转为较小字长的无符号数(无符号数的截断)

例如 int 转 short (32位 转 16位)

![](.\不同字长整数之间的转换3.png)

此时将会丢弃高位仅保留低位,对应例子中的 int 转 short 就是保留低16位(short共16位),舍弃高16位(32 - 16).

![](.\不同字长整数之间的转换4.png)

按照截断理解就是,对于一个 w 位的无符号数对应的位向量 x, 截断成k位时,丢弃最高的 w - k 位.

截断操作可以对应为取模运算,对于二进制取模,通俗理解就是除以 2 的 k 次方后得到的余数.

![](.\不同字长整数之间的转换5.png)

类比10进制数 123,456 mod 10 ^ 3 将会得到 456 (6位 - 3位 最后保留了 最低位3位).



### 较大字长的有符号数转为较小字长的有符号数(有符号数的截断)

![](.\不同字长整数之间的转换6.png)

将顶部公式分解为两步来理解即可(截断 + 重新解释,先改变大小再改变符号)

#### 第一步:截断

​	采用与无符号数相同的截断方式,得到最低的k位,即将该有符号数对2的k次方取余,(k为应当截断的位数,为大位数与小位数的差值 如 int 转 short 为 32 - 16 = 16).

#### 第二步:重新解释

​	将截断后的有符号数转为对应的有符号数.